<HTML>

<head>
<script src="js/createjs.min.js"></script>
<script src="js/KeyMonkey.js"></script>
<script src="js/collisionGnome.js"></script>
<script>

// variables
var myStage;
var stageWidth;
var stageHeight;
var myFrameRate = 60;
var stageMargin = 128; 

var hero;
var heroStartSpeedX = 10;
var heroStartSpeedY = 10;
var heroStartPositionX = 800;
var heroStartPositionY = 830;

var targetsArray = [ ];
var numberOfTargets = 20;
var targetMaxSpeed = 8; 
var targetMinSpeed = 4;
var targetMaxScale = 1.15;
var targetMinScale = .8;

var bg;

var scoreText;

var score;
var gameClock;
var gameOver;
var gameOverDuration = 200;

function init(){	
	console.log("hello from init()");
	// initialize stage
	myStage = new createjs.Stage(document.getElementById("myCanvas"));
	stageWidth = myStage.canvas.width;
	stageHeight = myStage.canvas.height;

	// initialize ticker	
	createjs.Ticker.addEventListener('tick', drawNewFrame);
	createjs.Ticker._setFPS(myFrameRate);

	// initialize game
	initGame();			
}

// ************   initGame() runs at init and reset ****************
function initGame(){	

	// initialize game variables 
	console.log("hello from initGame()");
	score = 0;				
	
	gameClock = 0;				

	gameOver = false;		

	targetsArray = [ ];
	hero = null;
	bg = null;
	// initialize stage objects
	makeBackground("images/background.png"); 	// initialize background
	makeTargets (numberOfTargets); 				// initialize targets 
	makeHero(); 								// initialize hero
	makeScoreText();							// initialize scoreText
	collisionGnome.setDebug(false); 


}

// *****************  	MAIN LOOP  	************************
// drawNewFrame() This function is called 60 x per second, on every 'tick' event

function drawNewFrame(evt){

	checkBoundaryTargets();
    checkBoundaryHero(); 
	moveTargets();
    moveHero();   
    checkCollisions();  	

    updateScoreText();	

    checkGameOver();	

   	handleGameOver();	

    gameClock ++;	

	myStage.update();
			
}


// ***************** 	MAKE THINGS    *************************

function makeBackground(whichBackground){ // takes a string containing the filepath i.e. "images/background.png"
	background = new createjs.Bitmap(whichBackground);
	myStage.addChild(background);
}
function makeScoreText(){
	scoreText = new createjs.Text("Score: " + score, "50px Arial", "#eda6d4");
	scoreText.x = 30;
	scoreText.y = 80;
	scoreText.textBaseline = "alphabetic";
	myStage.addChild(scoreText);
}
function makeHero(){		 
	hero = new createjs.Bitmap("images/hero.png");
	if(heroStartPositionX === undefined){ hero.x = stageWidth/2; } else { hero.x = heroStartPositionX; }
	if(heroStartPositionY === undefined){ hero.y = stageHeight/2; } else { hero.y = heroStartPositionY; }
	myStage.addChild(hero);
	hero.regX = 64;
	hero.regY = 64;
	hero.speedX = heroStartSpeedX;
	hero.speedY = heroStartSpeedY;
	// *** Add collision detection to hero ***
	collisionGnome.addCollider(hero, 1); // (sprite, hitBoxRatio)						
}		
function makeTargets(howManyTargets){

	for (var i =0; i<howManyTargets; i++){
		// roll a random integer: 0, 1, or 2 and store it in the new variable 'whichTargedt'
        var whichTarget = Math.floor(Math.random()*3); 

        // This switch statement checks our 'whichTarget' value and assigns a different Bitmap 
        // for each possible value... 0, 1, or 2
        switch(whichTarget){
        	case 0:
        		targetsArray[i] = new createjs.Bitmap("images/target01.png");
        		break;
        	case 1:
        		targetsArray[i] = new createjs.Bitmap("images/target02.png");
        		break;
        	case 2:
        		targetsArray[i] = new createjs.Bitmap("images/target03.png");
        		break;
        } // end switch

        targetsArray[i].regX = 32;
        targetsArray[i].regY = 32;
        
        targetsArray[i].x = Math.floor(Math.random()*(stageWidth-2*stageMargin))+stageMargin;
        targetsArray[i].y = Math.floor(Math.random()*(stageWidth-2*stageMargin))+stageMargin;
        targetsArray[i].scaleX = targetsArray[i].scaleY = rollRange(targetMinScale, targetMaxScale, false);
    
        targetsArray[i].speedX = rollRange(targetMinSpeed, targetMaxSpeed, true);
        targetsArray[i].speedY = rollRange(targetMinSpeed, targetMaxSpeed, true);
    
    	var coinTossX = Math.random(); // flip a coin to see if the target starts off moving left or right
    	//if(coinTossX > .5) { targetsArray[i].speedX = - targetsArray[i].speedX; }
    	var coinTossY = Math.random(); // flip a coin to see if the target starts off moving up or down
     	//if(coinTossY > 10000000000) { targetsArray[i].speedY = - targetsArray[i].speedY; }

     	// *** Add collision code to each target ***
		collisionGnome.addCollider(targetsArray[i], 1); // (sprite, hitBoxRatio)			// $$$$$	
      		        
        myStage.addChild(targetsArray[i]);  
	} 
}

	
// ***************** 	MOVEMENT     ****************

function moveHero(){ 
	   
//	if(keyMonkey["w"] || keyMonkey["up"]) 	{hero.y -= hero.speedY; }
//	if(keyMonkey["s"] || keyMonkey["down"]) {hero.y += hero.speedY; }
	if(keyMonkey["d"] || keyMonkey["right"]) {hero.x += hero.speedX; }
	if(keyMonkey["a"] || keyMonkey["left"]) {hero.x -= hero.speedX; }

}

function moveTargets(){
	for(var i = 0; i < targetsArray.length; i++){
		//targetsArray[i].x += targetsArray[i].speedX;
		targetsArray[i].y += targetsArray[i].speedY;
	} 
}

// ***************** 	BOUNDARIES AND COLLISIONS    ************
		
function checkBoundaryTargets(){
	for(var i = 0; i<targetsArray.length; i++){	

	if(targetsArray[i].x > stageWidth-targetsArray[i].regX || targetsArray[i].x < targetsArray[i].regX) {
			//console.log("off STAGE");
		targetsArray[i].speedX = -targetsArray[i].speedX;
		}// end if
		if(targetsArray[i].y > stageHeight-targetsArray[i].regY || targetsArray[i].y < targetsArray[i].regY) {
			console.log("off STAGE");
			targetsArray[i].speedY = -targetsArray[i].speedY;
		}// end if
	}// end for
}// end targetBoundaryCheck()
		
function checkBoundaryHero(){

	if(hero.x > stageWidth + hero.regX) {
		hero.x = -hero.regX;
	}// end if
	if(hero.x < 0 - hero.regX) {
		hero.x = stageWidth + hero.regX - 1;
	}// end if
	if(hero.y > stageWidth + hero.regY) {
		hero.y = -hero.regY +1;
	}// end if
	if(hero.y < 0 - hero.regY) {
		hero.y = stageWidth + hero.regY - 1;
	}// end if	

}// end heroBoundaryCheck()

function checkCollisions() {																// $$$$$...
	if(!gameOver){
		for(var i = targetsArray.length-1; i>=0; i--) {
			if(hero.collidesWith(targetsArray[i])){ 
				score ++;
				myStage.removeChild(targetsArray[i]);
				targetsArray.splice(i, 1);
			} // end if
		} // end for
	}
} // end handleCollisions()																	// ... $$$$$

// ********************* SCORE AND GAME OVER *******************
function updateScoreText(){	
	if(!gameOver){
		scoreText.text = "Score: " + score;
	}else{
		scoreText.text = "You Win!";
	}																						// $$$$$ ...
	
} // END UPDATE SCORE 				

function checkGameOver(){																	// $$$$$ ...
	if (score === numberOfTargets && gameOver === false) { 		// game over conditions
		gameOver = true;
		gameClock = 0;
		console.log('this game is over!');
	} // end if
} // end checkGameOver()

function handleGameOver(){
	if (gameOver === true){
		if (gameClock > gameOverDuration){	
			console.log("hello from handleGameOver");
			myStage.removeAllChildren();
			initGame();
		}
	}// end if
} // end handleGameOver()																	// ... $$$$$												

// ***************** 	UTILITIES     *************************

function rollRange(bottomEnd, topEnd, integerIfTrue){ 
// returns a random # between bottomEnd and topEnd. 
// The integerIfTrue parameter takes a boolean argument. 
	if(integerIfTrue){
		return Math.floor(Math.random() * (topEnd - bottomEnd + 1)) + bottomEnd;
	}else{
		return Math.random() * (topEnd - bottomEnd + 1) + bottomEnd;
	}// end else
}// end rollRange()

// ***************** 	END JAVASCRIPT     *************************			
	
</script>

<title>Leeky Notes</title>
</head>

<body onload="init()" style="text-align: center;">
	<a href="index.html"><img src="images/logo.png"></a>
	<br>
<canvas id="myCanvas" width="1600" height="900">This browser does not support HTML5, try using chrome, Firefox, or Safari on PC or Mac and try again.</canvas>
</body>
</HTML>